from typing import Any, Literal, Self, TypeVar, Union, override

from lorelie.backends import SQLiteBackend
from lorelie.fields.base import (BinaryField, CharField, CommaSeparatedField,
                                 DateField, DateTimeField, EmailField,
                                 FilePathField, FloatField, IntegerField,
                                 JSONField, SlugField, URLField, UUIDField)
from lorelie.functions import Functions

OutputFieldOptions = TypeVar(
    'OutputFieldOptions',
    CharField,
    CommaSeparatedField,
    BinaryField,
    DateTimeField,
    DateField,
    EmailField,
    FilePathField,
    FloatField,
    IntegerField,
    JSONField,
    SlugField,
    UUIDField,
    URLField
)


class BaseExpression:
    template_sql: str = ...

    @property
    def internal_type(self) -> Literal['expression']: ...

    def as_sql(self, backend: SQLiteBackend) -> str: ...


class Value:
    output_field: Union[
        CharField,
        DateField,
        DateTimeField,
        EmailField,
        FilePathField,
        FloatField,
        IntegerField,
        JSONField,
        SlugField,
        UUIDField,
        URLField
    ]
    value: Any = ...
    internal_name: str = ...

    def __init__(
        self,
        value: Any,
        output_field: OutputFieldOptions = ...
    ) -> None: ...

    def __repr__(self) -> str: ...

    def get_output_field(self) -> None: ...
    def to_python(self, value: Any) -> Any: ...
    def to_database(self) -> Union[str, list, dict, int, float]: ...
    def as_sql(self, backend: SQLiteBackend) -> list[str]: ...


class When(BaseExpression):
    condition: str = ...
    then_case: str = ...
    else_case: str = ...
    field_name: str = ...

    def __init__(self, condition: str, then_case: str, **kwargs) -> None: ...
    def __repr__(self) -> str: ...


class Case(BaseExpression):
    field_name: str = ...
    alias_field_name: str = ...
    default: str = ...
    cases: list[When] = ...

    def __init__(self, *cases: When, default: str = ...) -> None: ...
    def __repr__(self) -> str: ...


class CombinedExpression:
    template_sql: str = ...
    others: list[BaseExpression, Functions] = ...
    children: list = ...
    alias_field_name: str = None

    def __init__(
        self,
        *funcs: Union[BaseExpression, Functions]
    ) -> None: ...

    def __repr__(self) -> str: ...
    def __or__(self, other: Union[BaseExpression, Functions]) -> Self: ...
    def __and__(self, other: Union[BaseExpression, Functions]) -> Self: ...
    def __add__(self, other: Union[BaseExpression, Functions]) -> Self: ...
    def __sub__(self, other: Union[BaseExpression, Functions]) -> Self: ...
    def __div__(self, other: Union[BaseExpression, Functions]) -> Self: ...
    def __mul__(self, other: Union[BaseExpression, Functions]) -> Self: ...

    def build_children(self, operator: str = ...) -> None: ...
    def as_sql(self, backend) -> list[str]: ...


class Q(BaseExpression):
    def __init__(self, **expressions) -> None: ...
    def __repr__(self) -> str: ...
    def __and__(self, other: Q) -> CombinedExpression: ...
    def __or__(self, other: Q) -> CombinedExpression: ...
    @override
    def as_sql(self, backend: SQLiteBackend) -> list[str]: ...


class F(BaseExpression):
    ADD: str = ...
    SUBSRACT: str = ...
    MULTIPLY: str = ...
    DIVIDE: str = ...
    field: str = ...

    def __init__(self, field: str) -> None: ...
    def __repr__(self) -> str: ...
    def __add__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __mul__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __div__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __sub__(self, func: Union[str, int, F]) -> CombinedExpression: ...
