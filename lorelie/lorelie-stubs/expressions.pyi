from typing import Any, Literal, Optional, Self, TypeVar, Union, override

from lorelie.backends import SQLiteBackend
from lorelie.database.functions.base import Functions
from lorelie.fields.base import (BinaryField, CharField, CommaSeparatedField,
                                 DateField, DateTimeField, EmailField,
                                 FilePathField, FloatField, IntegerField,
                                 JSONField, SlugField, URLField, UUIDField)

OutputFieldOptions = TypeVar(
    'OutputFieldOptions',
    CharField,
    CommaSeparatedField,
    BinaryField,
    DateTimeField,
    DateField,
    EmailField,
    FilePathField,
    FloatField,
    IntegerField,
    JSONField,
    SlugField,
    UUIDField,
    URLField
)


class BaseExpression:
    template_sql: str = ...

    @property
    def internal_type(self) -> Literal['expression']: ...

    def as_sql(self, backend: SQLiteBackend) -> str: ...


class Value:
    output_field: Union[
        CharField,
        DateField,
        DateTimeField,
        EmailField,
        FilePathField,
        FloatField,
        IntegerField,
        JSONField,
        SlugField,
        UUIDField,
        URLField
    ]
    value: Any = ...
    internal_name: str = ...

    def __init__(
        self,
        value: Any,
        output_field: OutputFieldOptions = ...
    ) -> None: ...

    def __repr__(self) -> str: ...

    def get_output_field(self) -> None: ...
    def to_python(self, value: Any) -> Any: ...
    def to_database(self) -> Union[str, list, dict, int, float]: ...
    def as_sql(self, backend: SQLiteBackend) -> list[str]: ...


class NegatedExpression(BaseExpression):
    children: list[BaseExpression] = ...
    seen_expressions: list[BaseExpression] = ...

    def __init__(self, expression: BaseExpression) -> None: ...
    def __and__(self, other: Union[Q, F, NegatedExpression]) -> Self: ...


class When(BaseExpression):
    condition: Union[Q, str] = ...
    then_case: str = ...
    else_case: str = ...
    field_name: str = ...

    def __init__(
        self,
        condition: Union[Q, str],
        then_case: str,
        **kwargs
    ) -> None: ...

    def __repr__(self) -> str: ...


class Case(BaseExpression):
    field_name: str = ...
    alias_field_name: str = ...
    default: str = ...
    cases: list[When] = ...

    def __init__(self, *cases: When, default: Optional[str] = ...) -> None: ...
    def __repr__(self) -> str: ...

    @override
    def as_sql(self, backend: SQLiteBackend) -> str: ...


class CombinedExpression:
    template_sql: str = ...
    others: list[BaseExpression, Functions] = ...
    children: list = ...
    alias_field_name: str = None

    def __init__(
        self,
        *funcs: Union[BaseExpression, Functions]
    ) -> None: ...

    def __repr__(self) -> str: ...

    def __or__(
        self,
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def __and__(
        self, 
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def __add__(
        self, 
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def __sub__(
        self, 
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def __div__(
        self, 
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def __mul__(
        self, 
        other: Union[BaseExpression, Functions]
    ) -> CombinedExpression: ...

    def build_children(self, operator: str = ...) -> None: ...
    def as_sql(self, backend) -> list[str]: ...


class Q(BaseExpression):
    def __init__(self, **expressions) -> None: ...
    def __repr__(self) -> str: ...
    def __and__(self, other: Q) -> CombinedExpression: ...
    def __or__(self, other: Q) -> CombinedExpression: ...
    def __invert__(self, other: Q) -> NegatedExpression: ...

    @override
    def as_sql(self, backend: SQLiteBackend) -> list[str]: ...


class F(BaseExpression):
    ADD: str = ...
    SUBSRACT: str = ...
    MULTIPLY: str = ...
    DIVIDE: str = ...
    field: str = ...

    def __init__(self, field: str) -> None: ...
    def __repr__(self) -> str: ...
    def __add__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __mul__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __div__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __sub__(self, func: Union[str, int, F]) -> CombinedExpression: ...
    def __neg__(self) -> NegatedExpression: ...

    @override
    def as_sql(self, backend: SQLiteBackend) -> list[str]: ...
