import datetime
from collections.abc import Awaitable
from typing import (Any, ClassVar, Dict, Literal, NamedTuple, Optional,
                    Protocol, Type, Union)

import pandas

from lorelie.backends import BaseRow
from lorelie.database.base import Database
from lorelie.database.functions.aggregation import Avg, Count, Sum
from lorelie.queries import Query, QuerySet, ValuesIterable
from lorelie.tables import RelationshipMap, Table


class DataclassProtocol(Protocol):
    __dataclass_fields__: ClassVar[Dict[str, Any]]


class DatabaseManager:
    table: Table = ...
    database: Database = ...
    table_map: dict[str, Table] = ...
    auto_created: bool = Literal[True]

    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...

    def __get__(
        self,
        instance: Table,
        cls: Optional[Type[Table]] = ...
    ) -> DatabaseManager: ...

    @classmethod
    def as_manager(
        cls,
        table_map: Optional[dict] = ...,
        database: Optional[Database] = ...
    ) -> DatabaseManager: ...

    def _validate_auto_fields(
        self,
        table: Table,
        params: dict[str, str],
        update_only: Optional[bool] = ...
    ) -> dict[str, str]: ...

    def pre_save(
        self,
        selected_table: Table,
        data: list[Any]
    ) -> NamedTuple: ...

    def first(self) -> BaseRow: ...
    def last(self) -> BaseRow: ...
    def all(self) -> QuerySet: ...
    def create(self, **kwargs) -> BaseRow: ...
    def filter(self, *args, **kwargs) -> QuerySet: ...
    def get(self, *args, **kwargs) -> BaseRow: ...
    def annotate(self, *args, **kwargs) -> QuerySet: ...
    def values(self, *fields: str) -> ValuesIterable: ...
    def dataframe(self, *fields) -> pandas.DataFrame: ...

    def bulk_create(
        self,
        objs: list[DataclassProtocol]
    ) -> QuerySet: ...

    def order_by(self, *fields: str) -> QuerySet: ...
    def count(self) -> int: ...

    def dates(
        self,
        field: str,
        field_to_sort: Optional[str] = ...,
        ascending: Optional[bool] = ...
    ) -> list[datetime.date]: ...

    def datetimes(
        self,
        field: str,
        field_to_sort: Optional[str] = ...,
        ascending: Optional[bool] = ...
    ) -> list[datetime.datetime]: ...

    def difference(self, *qs: QuerySet) -> QuerySet: ...
    def distinct(self, *fields: str) -> QuerySet: ...
    def earliest(self, *fields: str) -> BaseRow: ...
    def latest(self, *fields: str) -> BaseRow: ...
    def only(self, *fields) -> QuerySet: ...
    def exclude(self, *args, **kwargs) -> QuerySet: ...
    def extra(self) -> QuerySet: ...

    def get_or_create(
        self,
        create_defaults: Optional[dict[str, Any]] = ...,
        **kwargs
    ) -> BaseRow: ...

    # def select_for_update(self, table: str) -> QuerySet: ...
    # def select_related(self, table: str) -> QuerySet: ...
    # def fetch_related(self, table: str) -> QuerySet: ...

    def update_or_create(
        self,
        create_defaults: Optional[dict[str, Any]] = ...,
        **kwargs
    ) -> BaseRow: ...

    def intersect(
        self,
        qs1: QuerySet,
        qs2: QuerySet
    ) -> QuerySet: ...

    def resolve_expression(
        self,
    ) -> Union[BaseRow, QuerySet]: ...

    def aggregate(
        self,
        *args: Union[Count, Avg, Sum],
        **kwargs
    ) -> dict[str, int]: ...

    def count(self) -> int: ...

    async def afirst(self) -> Awaitable[BaseRow]: ...
    async def alast(self) -> Awaitable[BaseRow]: ...
    async def aall(self) -> Awaitable[QuerySet]: ...
    async def acreate(self, **kwargs) -> Awaitable[BaseRow]: ...

    async def afilter(
        self,
        *args,
        **kwargs
    ) -> Awaitable[QuerySet]: ...

    async def aget(
        self,
        *args, **kwargs
    ) -> Awaitable[BaseRow]: ...

    async def aannotate(
        self,
        *args, **kwargs
    ) -> Awaitable[QuerySet]: ...

    async def avalues(
        self,
        *fields: str
    ) -> Awaitable[ValuesIterable]: ...

    async def adataframe(
        self,
        *fields
    ) -> Awaitable[pandas.DataFrame]: ...

    async def abulk_create(
        self,
        objs: list[DataclassProtocol]
    ) -> Awaitable[QuerySet]: ...

    async def aorder_by(
        self,
        *fields: str
    ) -> Awaitable[QuerySet]: ...

    async def acount(self) -> Awaitable[int]: ...

    async def adates(
        self,
        field: str,
        field_to_sort: Optional[str] = ...,
        ascending: Optional[bool] = ...
    ) -> Awaitable[list[datetime.date]]: ...

    async def adatetimes(
        self,
        field: str,
        field_to_sort: Optional[str] = ...,
        ascending: Optional[bool] = ...
    ) -> Awaitable[list[datetime.datetime]]: ...

    async def adifference(
        self,
        *qs: QuerySet
    ) -> Awaitable[QuerySet]: ...

    async def adistinct(
        self,
        *fields: str
    ) -> Awaitable[QuerySet]: ...

    async def aearliest(
        self,
        *fields: str
    ) -> Awaitable[BaseRow]: ...

    async def alatest(
        self,
        *fields: str
    ) -> Awaitable[BaseRow]: ...

    async def aonly(
        self,
        *fields
    ) -> Awaitable[QuerySet]: ...

    async def aexclude(
        self,
        *args,
        **kwargs
    ) -> Awaitable[QuerySet]: ...

    async def aextra(self) -> Awaitable[QuerySet]: ...

    async def aget_or_create(
        self,
        create_defaults: Optional[dict[str, Any]] = ...,
        **kwargs
    ) -> Awaitable[BaseRow]: ...

    # async def aselect_for_update(self, table: str) -> Awaitable[QuerySet]: ...
    # async def aselect_related(self, table: str) -> Awaitable[QuerySet]: ...
    # async def afetch_related(self, table: str) -> Awaitable[QuerySet]: ...

    async def aupdate_or_create(
        self,
        create_defaults: Optional[dict[str, Any]] = ...,
        **kwargs
    ) -> Awaitable[BaseRow]: ...

    async def aresolve_expression(
        self
    ) -> Awaitable[Union[BaseRow, QuerySet]]: ...

    async def aaggregate(
        self,
        *args: Union[Count, Avg, Sum],
        **kwargs
    ) -> Awaitable[dict[str, int]]: ...


class ForeignTablesManager:
    reverse: bool = ...
    table: Table = ...
    parent_table: Table = ...
    relationship_map: RelationshipMap = ...

    def __init__(
        self,
        relationship_map: RelationshipMap
    ) -> None: ...

    def __repr__(self) -> None: ...

    @classmethod
    def new(
        cls,
        table: Table,
        relationship_map: RelationshipMap,
        reverse: Optional[bool] = ...
    ) -> ForeignTablesManager: ...

    def all(self) -> QuerySet: ...
    def create(self, **kwargs) -> BaseRow: ...


class ForwardForeignTableManager(ForeignTablesManager):
    ...


class BackwardForeignTableManager(ForeignTablesManager):
    ...
