import datetime
from collections.abc import Awaitable, Coroutine
from typing import (Any, ClassVar, Dict, Literal, NamedTuple, Protocol, Type,
                    Union)

import pandas

from lorelie.aggregation import Avg, Count, Sum
from lorelie.backends import BaseRow
from lorelie.database.base import Database, RelationshipMap
from lorelie.queries import QuerySet, ValuesIterable
from lorelie.tables import Table

class DataclassProtocol(Protocol):
    __dataclass_fields__: ClassVar[Dict[str, Any]] 


class DatabaseManager:
    table_map: dict[str, Table] = ...
    database: Database = ...
    auto_created: bool = Literal[True]

    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...

    def __get__(
        self,
        instance: Database,
        cls: Type[Database] = ...
    ) -> DatabaseManager: ...

    @classmethod
    def as_manager(
        cls,
        table_map: dict = ...,
        database: Database = ...
    ) -> DatabaseManager: ...

    def _get_select_sql(
        self,
        selected_table: Table,
        columns: list = ...
    ) -> list[str]: ...

    def _get_first_or_last_sql(
        self,
        selected_table: Table, first: bool = Literal[True]
    ) -> list[str]: ...

    def pre_save(
        self,
        selected_table: Table,
        data: list[Any]
    ) -> NamedTuple: ...

    def before_action(self, table_name: str) -> Table: ...
    def first(self, table: str) -> BaseRow: ...
    def last(self, table: str) -> BaseRow: ...
    def all(self, table: str) -> QuerySet[BaseRow]: ...
    def create(self, table: str, **kwargs) -> BaseRow: ...
    def filter(self, table: str, *args, **kwargs) -> QuerySet[BaseRow]: ...
    def get(self, table: str, *args, **kwargs) -> BaseRow: ...
    def annotate(self, table: str, *args, **kwargs) -> QuerySet[BaseRow]: ...
    def values(self, table: str, *fields: str) -> ValuesIterable: ...
    def dataframe(self, table: str, *fields) -> pandas.DataFrame: ...
    def bulk_create(self, table: str, objs: list[DataclassProtocol]) -> QuerySet[BaseRow]: ...
    def order_by(self, table: str, *fields: str) -> QuerySet[BaseRow]: ...
    def count(self, table: str) -> int: ...

    def dates(
        self,
        table: str,
        field: str,
        field_to_sort=Literal['year'],
        ascending=Literal[True]
    ) -> list[datetime.date]: ...

    def datetimes(
        self,
        table: str,
        field: str,
        field_to_sort=Literal['year'],
        ascending=Literal[True]
    ) -> list[datetime.datetime]: ...

    def difference(self, table: str, *qs: QuerySet) -> QuerySet[BaseRow]: ...
    def distinct(self, table: str, *fields: str) -> QuerySet[BaseRow]: ...
    def earliest(self, table: str, *fields: str) -> BaseRow: ...
    def latest(self, table: str, *fields: str) -> BaseRow: ...
    def only(self, table: str, *fields) -> QuerySet[BaseRow]: ...
    def exclude(self, table: str, *args, **kwargs) -> QuerySet[BaseRow]: ...
    def extra(self, table: str) -> QuerySet[BaseRow]: ...

    def get_or_create(
        self, table: str,
        create_defaults: dict = ...,
        **kwargs
    ) -> BaseRow: ...

    def select_for_update(self, table: str) -> QuerySet[BaseRow]: ...
    def select_related(self, table: str) -> QuerySet[BaseRow]: ...
    def fetch_related(self, table: str) -> QuerySet[BaseRow]: ...

    def update_or_create(
        self, 
        table: str,
        create_defaults: dict[str, Any] = ...,
        **kwargs
    ) -> QuerySet: ...

    def resolve_expression(
        self,
        table: str
    ) -> Union[BaseRow, QuerySet[BaseRow]]: ...

    def aggregate(
        self,
        table: str,
        *args: Union[Count, Avg, Sum],
        **kwargs
    ) -> dict[str, int]: ...

    def count(self, table: str) -> int: ...

    async def aall(self, table: str) -> Awaitable[QuerySet]: ...


class ForeignTablesManager:
    reverse: bool = ...
    left_table: Table = ...
    right_table: Table = ...
    relatationship_name: str = ...
    relationship: RelationshipMap = ...
    database_manager: DatabaseManager = ...
    current_row: BaseRow = ...

    def __init__(
        self,
        right_table_name: str,
        left_table: Table,
        reverse: bool = ...
    ) -> None: ...

    def __repr__(self) -> None: ...

    def all(self) -> QuerySet: ...
    def last(self) -> BaseRow: ...
    def create(self, **kwargs) -> BaseRow: ...
