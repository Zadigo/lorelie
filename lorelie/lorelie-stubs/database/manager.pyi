from typing import Any, Literal, NamedTuple, Type, Union

import pandas
import datetime
from lorelie.aggregation import Avg, Count, Sum
from lorelie.backends import BaseRow
from lorelie.database.base import Database
from lorelie.queries import QuerySet, ValuesIterable
from lorelie.tables import Table


class DatabaseManager:
    table_map: dict[str, Table] = ...
    database: Database = ...
    auto_created: bool = Literal[True]

    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...

    def __get__(
        self,
        instance: Database,
        cls: Type[Database] = ...
    ) -> DatabaseManager: ...

    @classmethod
    def as_manager(
        cls,
        table_map: dict = ...,
        database: Database = ...
    ) -> DatabaseManager: ...

    def _get_select_sql(
        self,
        selected_table: Table,
        columns: list = ...
    ) -> list[str]: ...

    def _get_first_or_last_sql(
        self,
        selected_table: Table, first: bool = Literal[True]
    ) -> list[str]: ...

    def pre_save(
        self,
        selected_table: Table,
        data: list[Any]
    ) -> NamedTuple: ...

    def before_action(self, table_name: str) -> Table: ...
    def first(self, table: str) -> BaseRow: ...
    def last(self, table: str) -> BaseRow: ...
    def all(self, table: str) -> QuerySet[BaseRow]: ...
    def create(self, table: str, **kwargs) -> BaseRow: ...
    def filter(self, table: str, *args, **kwargs) -> QuerySet[BaseRow]: ...
    def get(self, table: str, *args, **kwargs) -> BaseRow: ...
    def annotate(self, table: str, **kwargs) -> QuerySet[BaseRow]: ...
    def values(self, table: str, *fields: str) -> ValuesIterable: ...
    def dataframe(self, table: str, *fields) -> pandas.DataFrame: ...
    def bulk_create(self, table: str, *objs) -> QuerySet[BaseRow]: ...
    def order_by(self, table: str, *fields: str) -> QuerySet[BaseRow]: ...
    def count(self, table: str) -> int: ...

    def dates(
        self,
        table: str,
        field: str,
        field_to_sort=Literal['year'],
        ascending=Literal[True]
    ) -> list[datetime.date]: ...

    def datetimes(
        self,
        table: str,
        field: str,
        field_to_sort=Literal['year'],
        ascending=Literal[True]
    ) -> list[datetime.datetime]: ...

    def difference(self, table: str, *qs: QuerySet) -> QuerySet[BaseRow]: ...
    def distinct(self, table: str, *fields: str) -> QuerySet[BaseRow]: ...
    def earliest(self, table: str, *fields: str) -> BaseRow: ...
    def latest(self, table: str, *fields: str) -> BaseRow: ...
    def only(self, table: str, *fields) -> QuerySet[BaseRow]: ...
    def exclude(self, table: str, *args, **kwargs) -> QuerySet[BaseRow]: ...
    def extra(self, table: str) -> QuerySet[BaseRow]: ...

    def get_or_create(
        self, table: str,
        defaults: dict = ...,
        conflict_field: str = ...,
        **kwargs
    ) -> Union[BaseRow, QuerySet]: ...

    def select_for_update(self, table: str) -> QuerySet[BaseRow]: ...
    def select_related(self, table: str) -> QuerySet[BaseRow]: ...
    def fetch_related(self, table: str) -> QuerySet[BaseRow]: ...

    def update_or_create(
        self, table: str,
        update_defaults: dict = ...,
        create_defaults: dict = ...,
        conflict_field: str = ...,
        **kwargs
    ) -> QuerySet: ...

    def resolve_expression(
        self,
        table: str
    ) -> Union[BaseRow, QuerySet[BaseRow]]: ...

    def aggregate(
        self,
        table: str,
        *args: Union[Count, Avg, Sum],
        **kwargs
    ) -> dict[str, int]: ...

    def count(self, table: str) -> int: ...
    def foreign_table(self, relationship: str) -> ForeignTablesManager: ...


class ForeignTablesManager:
    manager: DatabaseManager = ...
    left_table: Table = ...
    right_table: Table = ...

    def __init__(
        self,
        left_table: str,
        right_table: str,
        manager: DatabaseManager
    ) -> None: ...
